# Что такое метка (label)?
Метка в ассемблере - это имя, которое указывает на конкретное место в программе, на которое можно сослаться в коде.

ИЛИ

Метка - это ссылка на адрес в памяти, в котором хранятся данные.

ИЛИ

Метка — это средство задания точки в программе или сред­ство хранения значения постоянных и переменных. 

ИЛИ

Мб пойдём погуляем куда-нибудь, ну этот АК не?

Необходимы для повышения человекочитаемости кода. С помощью них удобно создавать подобие переменных в секции .data, а также обращаться к отдельным участкам программы, т.е. совершать переходы 

Сами по себе метки не знаимают места в памяти.

Должны иметь уникальные имена.

В dump отчёта wrench есть отдельная область, в которой видно, на какой адрес та или иная метка ссылается (как это считается в следующем вопросе)

![image](https://github.com/user-attachments/assets/0a4b4381-17f0-4241-8e3d-fc430ed46759)

# Откуда рассчитываются значения меток (label)?
Ассемблер делает два прохода по тексту программы. На первом проходе проверяется правильность синтаксиса и рассчитываются
значения меток. Тому, как он это делает, и будет посвящена наша сегодняшняя история.

Ассемблер идет последовательно, начиная с начала сегмента .data (ячейка памяти с адресом 0)
Он считает размер каждой директивы (.byte, .word) или инструкции в байтах, а когда встречает метку - присваивает метке значение,
равное текущему счетчику байтов в таблице значений меток (пикча из первого вопроса) 
Размер каждой инструкции известен ассемблеру (зависит от архитектуры)

На втором проходе ♂ass♂embler чекает таблицу значений из первого прохода и подставляет в код
вместо меток реальные адреса.

# Как вывести в отчёте состояние регистра Acc в hex формате?
Возьмём, к примеру, f32a
В доке Пенского для каждой архитектуры есть список возможных представлений состояний регистров

![image](https://github.com/user-attachments/assets/7797acfa-80fa-44e4-8a48-a1fd88a4d0f7)

В yaml файле в разделе view прописываем регистры, состояния которых мы хотим видеть, с припиской hex.
На примере ниже вывели stack в шестнадцатиричном формате.

![image](https://github.com/user-attachments/assets/aecbd803-c472-417f-ae71-37d71de55f05)

Вот, что мы будем видеть в во вкладке simulation_log:

![image](https://github.com/user-attachments/assets/82cdf1a7-1c27-4e2b-bc5a-c86c3abb4981)

А вот Carry флаг, как мы видим по первой картинке, в hex вывести не получится, ну и пох

# Что такое Memory Mapped IO?

# Что будет, если процессор попытается прочитать инструкцию из адреса ввода-вывода?

# Назначение alignment (неиспользуемый буфер в секции данных)?

![image](https://github.com/user-attachments/assets/90bf1149-b9ac-41a8-9002-216756edba4e)

Бу, испугался, не бойся

Берем это

```alignment:     .word '＼(≧▽≦)／_＼(≧▽≦)／_＼(≧▽≦)／_＼(≧▽≦)／_'```

И опа

![image](https://github.com/user-attachments/assets/4d66b6b8-3269-4694-af8e-1815685cc00b)

В какой-то момент наша секция .text с инструкциями отъелась настолько, что стала занимать место влоть до ячейки 0x80 (то есть 128 в десятичной), а эта ячейка является input port, поэтому если процессор
попытается прочитать инструкции из него, то у него ничего не получится, поэтому в секцию .data мы вставляем такую приколюху, как alignment, чтобы расширить секцию .data. Я делаю для удобства
aligment 32 символьным, но по факту его размер можно подогнать таким образом, чтобы секция .text началась после адреса 0x84 (output port).

Посмотрим на dump до aligment. Видим, что инструкция halt попала в адрес 128 (0x80), и процессор, попытаясь ее прочитать, подумает, что хотел бы стать chill guy, а не вот это вот все.

![image](https://github.com/user-attachments/assets/4dd32571-0f51-4465-bb4f-592de5fa8ef0)

Вставили alignment, чекаем, что метка _start указывает на адрес 144, то есть мы проскочили все порты ввода-вывода, и проблем с чтением инструкций не возникнет

![image](https://github.com/user-attachments/assets/d7434ff9-b483-4057-a251-693fdb22f216)

# acc32 Зачем определены дублирующиеся инструкции load_addr и load?
Читайте про это в гайде к acc32, эти команды описаны подробно.
# acc32 Переполнение и перенос. Overflow и Carry флаги, иные способы обработки.

# Что означает инструкция ...? Объясните что происходит в строках ....
Включаем харизму и поясняем за машинные слова.
# Как сократить объём машинного кода? Какие ограничение/проблемы это создаст?

# risc-iv Что означает конструкция 0(t1)? Зачем она нужна?
Описано в гайде по risc-iv. Если кратко, то это по типу указателей на языке C, разыменование адреса.
Если спросят про смещение, расскажите про итерации в массиве.
## risc-iv Почему для загрузки слова регистр нужно две инструкции?
Описано в гайде risc-iv подробно. Продумано с моей стороны.
## f32a Почему в F32a удобно использовать процедуры?
Процедуры - это исполняемые части кода, вызов процедуры делаем с помощью call, возврат из неё - с
помощью return.

В f32a очень удобно их использовать благодаря стеку, так как не нужно продумывать передачу аргументов,
они просто кладутся через push на стек, а процедура снимает их через pop(у).

Также существует независимость между процедурами, то есть одна никак не влияет на другую, ведь
можно считать, что у каждой процедуры выделена своя часть стека, с которой она взаимодействует.

Возврат из процедуры тоже бархатно проходит, спасибо стеку возврата, который хранит адреса возвратов.

Также не нужно делать сохранение и восстановление регистров.

Рекурсивные вызовы офигенно работают в стековой архитектуре, опять же благодаря независимому пространству стека
у каждой процедуры.


# f32a Extended arithmetic mode. Назначение и использование.
Гайд, мои дорогие, в нём все ответы. 

Вот вам ёжик смешной, а то подумаете еще, что я халтурю

![image](https://github.com/user-attachments/assets/9b761222-444d-4c5e-ac02-7ec66fa4fe95)

# Особенности кодирования инструкций, плотность кода, проблемы доступа.

# Как вы можете сократить объём машинного кода? Продемонстрируйте.

# risc-iv Работа со стеком. Выделение памяти, передача данных в/из процедур.
Сбор инфы. Stay tuned.
 




 


