# Что такое метка (label)?
Метка в ассемблере - это имя, которое указывает на конкретное место в программе, на которое можно сослаться в коде.

ИЛИ

Метка - это ссылка на адрес в памяти, в котором хранятся данные.

ИЛИ

Метка — это средство задания точки в программе или сред­ство хранения значения постоянных и переменных. 

ИЛИ

Мб пойдём погуляем куда-нибудь, ну этот АК не?

Необходимы для повышения человекочитаемости кода. С помощью них удобно создавать подобие переменных в секции .data, а также обращаться к отдельным участкам программы, т.е. совершать переходы 

Сами по себе метки не занимают место в памяти.

Должны иметь уникальные имена.

В dump отчёта wrench есть отдельная область, в которой видно, на какой адрес та или иная метка ссылается (как это считается объяснил в следующем вопросе)

![image](https://github.com/user-attachments/assets/0a4b4381-17f0-4241-8e3d-fc430ed46759)

# Откуда рассчитываются значения меток (label)?
Ассемблер делает два прохода по тексту программы. На первом проходе проверяется правильность синтаксиса и рассчитываются
значения меток. Тому, как он это делает, и будет посвящена наша сегодняшняя история.

Ассемблер идет последовательно, начиная с начала сегмента .data (ячейка памяти с адресом 0)
Он считает размер каждой директивы (.byte, .word) или инструкции в байтах, а когда встречает метку - присваивает метке значение,
равное текущему счетчику байтов в таблице значений меток (пикча из первого вопроса) 
Размер каждой инструкции известен ассемблеру (зависит от архитектуры)

На втором проходе ♂ass♂embler чекает таблицу значений из первого прохода и подставляет в код
вместо меток реальные адреса.

# Как вывести в отчёте состояние регистра Acc в hex формате?
Возьмём, к примеру, f32a
В доке Пенского для каждой архитектуры есть список возможных представлений состояний регистров

![image](https://github.com/user-attachments/assets/7797acfa-80fa-44e4-8a48-a1fd88a4d0f7)

В yaml config (simulation_config поле в отчете wrench) в разделе view (между slice и assert) прописываем регистры, состояния которых мы хотим видеть, с припиской hex.
На примере ниже вывели stack в шестнадцатиричном формате.

![image](https://github.com/user-attachments/assets/5bd92413-b3af-45ed-ac6b-0a07196c6c17)


Вот, что мы будем видеть в во вкладке simulation_log:

![image](https://github.com/user-attachments/assets/82cdf1a7-1c27-4e2b-bc5a-c86c3abb4981)

А вот Carry флаг, как мы видим по первой картинке, в hex вывести не получится, ну и пох

Разберём, как выводить Acc

Для acc32:

![image](https://github.com/user-attachments/assets/7a361aa8-877b-4e55-925d-44162c460dc6)

Прописываем в yaml config:
```
slice: all
view: |
      {pc}:	{instruction}	{pc:label} Acc: {Acc:hex}
```
Тогда в simulation_log такую тему увидим:
 ```
19:	Add 8	 Acc: 0x00000008
```

# Что такое Memory Mapped IO?
У нас есть различные устройства ввода-вывода. С ними нужно обмениваться инфой, то есть принимать для обработки данные и отправлять полученные результаты. Memory Mapped IO позволяет процессору работать с устройствами как с обычными адресами в памяти (команды чтения и записи). То есть он пишет в адрес или читает из него, а на самом деле происходит обращение к устройству. То есть мы мапим определенный адрес, к примеру 0x80, и говорим, что это input port.

Это необходимо для того, чтобы, во-первых, не создавать отдельное адресное пространство для портов ввода-вывода, а во-вторых, не заводить специальные инструкции для операция записи и чтения из этих портов.
# Что будет, если процессор попытается прочитать инструкцию из адреса ввода-вывода?
Адреса input port и output port не предназначены для чтения из них инструкций, а только для обмена данными. Поэтому на аппаратном уровне нам нужно запрещать процессору читать из этих адресов инструкции, то есть когда счетчик команд PC достигнет этого адреса, нужно вызвать исключение/ошибку. Это и происходит, кста, выглядит таким образом:

![image](https://github.com/user-attachments/assets/a7b2d96a-c180-43cf-bfb0-654229f33ca5)


# Назначение alignment (неиспользуемый буфер в секции данных)?

![image](https://github.com/user-attachments/assets/90bf1149-b9ac-41a8-9002-216756edba4e)

Бу, испугался, не бойся

Берем это

```alignment:     .word '＼(≧▽≦)／_＼(≧▽≦)／_＼(≧▽≦)／_＼(≧▽≦)／_'```

И опа

![image](https://github.com/user-attachments/assets/4d66b6b8-3269-4694-af8e-1815685cc00b)

В какой-то момент наша секция .text с инструкциями отъелась настолько, что стала занимать место вплоть до ячейки 0x80 (то есть 128 в десятичной), а эта ячейка является input port, поэтому если процессор
попытается прочитать инструкции из него, то у него ничего не получится, поэтому в секцию .data мы вставляем такую приколюху, как alignment, чтобы расширить секцию .data. Я делаю для удобства
alignment 32 символьным, но по факту его размер можно подогнать таким образом, чтобы секция .text началась после адреса 0x84 (output port).

Посмотрим на dump до alignment. Видим, что инструкция halt попала в адрес 128 (0x80), и процессор, пытаясь ее прочитать, подумает, что хотел бы стать chill guy, а не вот это вот все.

![image](https://github.com/user-attachments/assets/4dd32571-0f51-4465-bb4f-592de5fa8ef0)

Вставили alignment, чекаем, что метка _start указывает на адрес 144, то есть мы проскочили все порты ввода-вывода, и проблем с чтением инструкций не возникнет

![image](https://github.com/user-attachments/assets/d7434ff9-b483-4057-a251-693fdb22f216)

Второе применение alignment - разделитель .byte и .word в памяти. Это нужно, чтобы word не налазили на незаполненное до полного слова байтами место. Иначе все инструкции сместятся и будут декодироваться не так, как мы их задумывали. Раз на раз не приходится, иногда можно этого не делать и все будет норм, но лучше перестраховаться.

# acc32 Зачем определены дублирующиеся инструкции load_addr и load?
Читайте про это в гайде к acc32, эти команды описаны подробно.
# acc32 Переполнение и перенос. Overflow и Carry флаги, иные способы обработки.
Что такое переполнение (не гордостью, что работаете со мной) и перенос (не дел на завтра) при битовых операциях, я надеюсь вы знаете. В acc32 их проверка происходит с помощью
операций условного перехода по состоянию флага, а также их очистка с помощью команд опять же.

Вопрос об иных способах обработки расплывчатый, но предположим. 1 способ. Если у вас был дискродед на первом курсе, то шарите, как это можно сделать с помощью анализа старшего бита каждого из
операндов и старшего бита результата. Вот, к примеру, я расписывал все возможные комбы для вычисления, будет ли carry или нет, где a - старший бит операнда a, b - b, r - r, логично. c - это carry, 1 - установлен, 0 - не установлен. Если будете вникать в эти комбы и думать, почему a = 0, b = 0, a r = 1, к примеру, то помните про возможный перенос 1 при сложении младших разрядов.
Для флага переполнения свои комбы. Итак, в программе это можно реализовать, получится программный контроль флагов, а не аппаратный.

![image](https://github.com/user-attachments/assets/2a8a52ca-b17f-40b3-91d7-6f33d4eeb698)

Есть еще подход, который не поддерживается в нашей архитектуре, но имеет место быть теоретически. Расширение операндов и результата до большего размера, к примеру, 64 бит, выполнение вычислений и далее проверка, что он не выходит за минимальную и максимальную границы 32 битного числа.

Еще как-то мутил другую темку, кароч если нам нужно сделать сложение и проверить, будет ли переполнение, мы из максимально возможного 32-битного числа отнимаем второй операнд, и проверяем, что если первый операнд больше получившейся разности, то переполнению быть. Вот так вот, братцы.

# Что означает инструкция ...? Объясните что происходит в строках ....
Включаем харизму и поясняем за машинные слова.
# Как сократить объём машинного кода? Какие ограничение/проблемы это создаст?
На примере f32a

```
lit 1
+
```

Целых две команды, но мы ведь знаем, что это доступный в других языках программирования inc. Так вот, чтобы сократить объем машинного кода, мы берём и вводим новые инструкции. У этого подхода есть минус, связанный с увеличением сложности процессора или интерпретатора команд.

Второй подход можно уменьшить размер загружаемых immediate_value или адресов, тогда размер инструкций сократится, но диапазон доступной памяти и данных ограничится.

Про удаление лишних инструкций или алгоритмическое ускорение программы в этом вопросе лучше не говорить, это скорее относится про улучшение написанной вами программы, чем к сокращению объема кода с точки зрения архитектурной организации.
# risc-iv Что означает конструкция 0(t1)? Зачем она нужна?
Описано в гайде по risc-iv. Если кратко, то это по типу указателей на языке C, разыменование адреса.
Если спросят про смещение, расскажите про итерации в массиве.
## risc-iv Почему для загрузки слова регистр нужно две инструкции?
Описано в гайде risc-iv подробно. Продумано с моей стороны.
## f32a Почему в F32a удобно использовать процедуры?
Процедуры - это исполняемые части кода, вызов процедуры делаем с помощью call, возврат из неё - с помощью return.

В f32a очень удобно их использовать благодаря стеку, так как не нужно продумывать передачу аргументов,
они просто кладутся через push на стек, а процедура снимает их через pop(у).

Также существует независимость между процедурами, то есть одна никак не влияет на другую, ведь
можно считать, что у каждой процедуры выделена своя часть стека, с которой она взаимодействует.

Возврат из процедуры тоже бархатно проходит, спасибо стеку возврата, который хранит адреса возвратов.

Также не нужно делать сохранение и восстановление регистров.

Рекурсивные вызовы офигенно работают в стековой архитектуре, опять же благодаря независимому пространству стека
у каждой процедуры.


# f32a Extended arithmetic mode. Назначение и использование.
Гайд, мои дорогие, в нём все ответы. 

Вот вам ёжик смешной, а то подумаете еще, что я халтурю

![image](https://github.com/user-attachments/assets/9b761222-444d-4c5e-ac02-7ec66fa4fe95)

# Особенности кодирования инструкций, плотность кода, проблемы доступа.
Особенности кодирования инструкций: Есть архитектуры с фиксированной длиной инструкций, к примеру, risc-iv все по 4 байта, а есть архитектуры с переменной длиной, к примеру, в f32a есть по 5, 1, ил 4 байта. К недостаткам первой можно отнести низкую плотность кода, но при этом такие инструкции легко декодировать, ведь заранее известно, через сколько байт закончится инструкция. К недостаткам второй относится более сложное декодирование (необходим механизм, определяющий длину инструкции), однако это окупается высокой плотностью кода (простые операции занимают меньше места в памяти)

Плотность кода:
Нужно выполнить набор команд. Высокая плотность кода будет означать, что программы будут использовать меньшее количество памяти для выполнения определенного функционала, чем программы с более низкой плотностью кода. Грубо говоря, плотность показывает, насколько эффективно используются n ячеек памяти для решения поставленной задачи.

Проблемы доступа:
Гонки за владение ресурсами при многопоточной обработке, недоступность для ввода-вывода устройств, ограничения размера памяти, перегрузка шины данных из-за большого числа устройств и тд.
# Как вы можете сократить объём машинного кода? Продемонстрируйте.
Спорный вопрос, по идее возникнуть не должен, так как я уверен, что делал все максимально эффективно, но всякое бывает. На практике, к примеру, повторяющиеся участки кода можно выделить в одну процедуру и вызывать её, это сократит объем кода. Просто, смотрите на куски кода и думаете, как я могу это сделать за меньшее число команд. Как вариант, можно добавить чутка неэффективности в программу для защиты от пу-пу-пууу во время ответа на этот вопрос на сдаче.
# risc-iv Работа со стеком. Выделение памяти, передача данных в/из процедур.
Сбор инфы. Stay tuned.
 




 


