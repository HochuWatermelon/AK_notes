# Что такое метка (label)?
Метка в ассемблере - это имя, которое указывает на конкретное место в программе, на которое можно сослаться в коде.

ИЛИ

Метка - это ссылка на адрес в памяти, в котором хранятся данные.

ИЛИ

Метка — это средство задания точки в программе или сред­ство хранения значения постоянных и переменных. 

ИЛИ

Мб пойдём погуляем куда-нибудь, ну этот АК не?

Необходимы для повышения человекочитаемости кода. С помощью них удобно создавать подобие переменных в секции .data, а также обращаться к отдельным участкам программы, т.е. совершать переходы 

Сами по себе метки не занимают место в памяти.

Должны иметь уникальные имена.

В dump отчёта wrench есть отдельная область, в которой видно, на какой адрес та или иная метка ссылается (как это считается объяснил в следующем вопросе)

![image](https://github.com/user-attachments/assets/0a4b4381-17f0-4241-8e3d-fc430ed46759)

# Откуда рассчитываются значения меток (label)?
Ассемблер делает два прохода по тексту программы. На первом проходе проверяется правильность синтаксиса и рассчитываются
значения меток. Тому, как он это делает, и будет посвящена наша сегодняшняя история.

Ассемблер идет последовательно, начиная с начала сегмента .data (ячейка памяти с адресом 0)
Он считает размер каждой директивы (.byte, .word) или инструкции в байтах, а когда встречает метку - присваивает метке значение,
равное текущему счетчику байтов в таблице значений меток (пикча из первого вопроса) 
Размер каждой инструкции известен ассемблеру (зависит от архитектуры)

На втором проходе ♂ass♂embler чекает таблицу значений из первого прохода и подставляет в код
вместо меток реальные адреса.

# Как вывести в отчёте состояние регистра Acc в hex формате?
Возьмём, к примеру, f32a
В доке Пенского для каждой архитектуры есть список возможных представлений состояний регистров

![image](https://github.com/user-attachments/assets/7797acfa-80fa-44e4-8a48-a1fd88a4d0f7)

В yaml config (simulation_config поле в отчете wrench) в разделе view (между slice и assert) прописываем регистры, состояния которых мы хотим видеть, с припиской hex.
На примере ниже вывели stack в шестнадцатиричном формате. Slice: all позволяет отслеживать состояние регистров после каждой комнады.

![image](https://github.com/user-attachments/assets/5bd92413-b3af-45ed-ac6b-0a07196c6c17)


Вот, что мы будем видеть в во вкладке simulation_log:

![image](https://github.com/user-attachments/assets/82cdf1a7-1c27-4e2b-bc5a-c86c3abb4981)

А вот Carry флаг, как мы видим по первой картинке, в hex вывести не получится, ну и пох

Разберём, как выводить Acc

Для acc32:

![image](https://github.com/user-attachments/assets/7a361aa8-877b-4e55-925d-44162c460dc6)

Прописываем в yaml config:
```
slice: all
view: |
      {pc}:	{instruction}	{pc:label} Acc: {Acc:hex}
```
Тогда в simulation_log такую тему увидим:
 ```
19:	Add 8	 Acc: 0x00000008
```

# Что такое Memory Mapped IO?
У нас есть различные устройства ввода-вывода. С ними нужно обмениваться инфой, то есть принимать для обработки данные и отправлять полученные результаты. Memory Mapped IO позволяет процессору работать с устройствами как с обычными адресами в памяти (команды чтения и записи). То есть он пишет в адрес или читает из него, а на самом деле происходит обращение к устройству. То есть мы мапим определенный адрес, к примеру 0x80, и говорим, что это input port.

Это необходимо для того, чтобы, во-первых, не создавать отдельное адресное пространство для портов ввода-вывода, а во-вторых, не заводить специальные инструкции для операция записи и чтения из этих портов.
# Что будет, если процессор попытается прочитать инструкцию из адреса ввода-вывода?
Адреса input port и output port не предназначены для чтения из них инструкций, а только для обмена данными. Поэтому на аппаратном уровне нам нужно запрещать процессору читать из этих адресов инструкции, то есть когда счетчик команд PC достигнет этого адреса, нужно вызвать исключение/ошибку. Это и происходит, кста, выглядит таким образом:

![image](https://github.com/user-attachments/assets/a7b2d96a-c180-43cf-bfb0-654229f33ca5)


# Назначение alignment (неиспользуемый буфер в секции данных)?

![image](https://github.com/user-attachments/assets/90bf1149-b9ac-41a8-9002-216756edba4e)

Бу, испугался, не бойся

Берем это

```alignment:     .byte '@@'```

И опа

![image](https://github.com/user-attachments/assets/4d66b6b8-3269-4694-af8e-1815685cc00b)

Помним, что процессору нельзя читать инструкции из адресов ввода-вывода. В нашем случае 128 (0x80) и 132 (0x84). Если адрес инструкции из секции .data совпадет с одним из адресов ввода-вывода, то возникнет ошибка.

Посмотрим на dump до alignment. Видим, что инструкция halt попала в адрес 128 (0x80), и процессор, пытаясь ее прочитать, подумает, что хотел бы стать chill guy, а не вот это вот все.

![image](https://github.com/user-attachments/assets/18f1cc57-4a67-4db7-ba55-f76779b50b68)


Вставили ``` alignment      .byte '@' ```, чекаем dump. Так как в alignment поместили 1 байт, видим, что адрес начала инструкции halt стал 129, то есть сместился с адреса ввода. Однако теперь другая команда StoreB налезла на наш input port, так как после смещения ее адрес стал равен 128.

![image](https://github.com/user-attachments/assets/603926bf-31e3-4b9c-aa88-f97560166a25)

А что, если увеличим количество байт в alignment    ``` alignment        .byte '@@' ```. Теперь смещение составляет 2 байта, давайте посмотрим, как изменился наш dump

![image](https://github.com/user-attachments/assets/f0f61027-cf7f-483f-a2dc-9607e42f742d)

О, ура! Больше ни одна команда не начинается с 128 или 132. Делаем вывод, если возникает ошибка чтения из 128 или 132, вставляем в конец секции .data байтовый alignment и начинаем увеличивать количество его байтов, пока все тесты не пройдутся, начиная с 1 байта (в основном, достаточно 1 или 2 байтов, но был случай, когда потребовалось 4 байта, это зависит еще от того, сколько места занимают инструкции в данной архитектуре). При этом может случиться так, что одни тесты проходятся с текущим alignment, а другие нет, это связано с тем, что в зависимости от входных операндов, программа может занимать разное место в памяти.

Другой случай применения alignment будет описан в гайде на строки.

# acc32 Зачем определены дублирующиеся инструкции load_addr и load?
Читайте про это в гайде к acc32, эти команды описаны подробно.
# acc32 Переполнение и перенос. Overflow и Carry флаги, иные способы обработки.
Что такое переполнение (не гордостью, что работаете со мной) и перенос (не дел на завтра) при битовых операциях, я надеюсь вы знаете. В acc32 их проверка происходит с помощью
операций условного перехода по состоянию флага, а также их очистка с помощью команд опять же.

Вопрос об иных способах обработки расплывчатый, но предположим. 1 способ. Если у вас был дискродед на первом курсе, то шарите, как это можно сделать с помощью анализа старшего бита каждого из
операндов и старшего бита результата. Вот, к примеру, я расписывал все возможные комбы для вычисления, будет ли carry или нет, где a - старший бит операнда a, b - b, r - r, логично. c - это carry, 1 - установлен, 0 - не установлен. Если будете вникать в эти комбы и думать, почему a = 0, b = 0, a r = 1, к примеру, то помните про возможный перенос 1 при сложении младших разрядов.
Для флага переполнения свои комбы. Итак, в программе это можно реализовать, получится программный контроль флагов, а не аппаратный.

![image](https://github.com/user-attachments/assets/2a8a52ca-b17f-40b3-91d7-6f33d4eeb698)

Есть еще подход, который не поддерживается в нашей архитектуре, но имеет место быть теоретически. Расширение операндов и результата до большего размера, к примеру, 64 бит, выполнение вычислений и далее проверка, что он не выходит за минимальную и максимальную границы 32 битного числа.

Еще как-то мутил другую темку, кароч если нам нужно сделать сложение и проверить, будет ли переполнение, мы из максимально возможного 32-битного числа отнимаем второй операнд, и проверяем, что если первый операнд больше получившейся разности, то переполнению быть. Вот так вот, братцы.

# Что означает инструкция ...? Объясните что происходит в строках ....
Включаем харизму и поясняем за машинные слова.
# Как сократить объём машинного кода? Какие ограничение/проблемы это создаст?
На примере f32a

```
lit 1
+
```

Целых две команды, но мы ведь знаем, что это доступный в других языках программирования inc. Так вот, чтобы сократить объем машинного кода, мы берём и вводим новые инструкции. У этого подхода есть минус, связанный с увеличением сложности процессора или интерпретатора команд.

Второй подход можно уменьшить размер загружаемых immediate_value или адресов, тогда размер инструкций сократится, но диапазон доступной памяти и данных ограничится.

Про удаление лишних инструкций или алгоритмическое ускорение программы в этом вопросе лучше не говорить, это скорее относится про улучшение написанной вами программы, чем к сокращению объема кода с точки зрения архитектурной организации.
# risc-iv Что означает конструкция 0(t1)? Зачем она нужна?
Описано в гайде по risc-iv. Если кратко, то это по типу указателей на языке C, разыменование адреса.
Если спросят про смещение, расскажите про итерации в массиве.
## risc-iv Почему для загрузки слова регистр нужно две инструкции?
Описано в гайде risc-iv подробно. Продумано с моей стороны.
## f32a Почему в F32a удобно использовать процедуры?
Процедуры - это исполняемые части кода, вызов процедуры делаем с помощью call, возврат из неё - с помощью return.

В f32a очень удобно их использовать благодаря стеку, так как не нужно продумывать передачу аргументов,
они просто кладутся через push на стек, а процедура снимает их через pop(у).

Также существует независимость между процедурами, то есть одна никак не влияет на другую, ведь
можно считать, что у каждой процедуры выделена своя часть стека, с которой она взаимодействует.

Возврат из процедуры тоже бархатно проходит, спасибо стеку возврата, который хранит адреса возвратов.

Также не нужно делать сохранение и восстановление регистров.

Рекурсивные вызовы офигенно работают в стековой архитектуре, опять же благодаря независимому пространству стека
у каждой процедуры.


# f32a Extended arithmetic mode. Назначение и использование.
Гайд, мои дорогие, в нём все ответы. 

Вот вам ёжик смешной, а то подумаете еще, что я халтурю

![image](https://github.com/user-attachments/assets/9b761222-444d-4c5e-ac02-7ec66fa4fe95)

# Особенности кодирования инструкций, плотность кода, проблемы доступа.
Особенности кодирования инструкций: Есть архитектуры с фиксированной длиной инструкций, к примеру, risc-iv все по 4 байта, а есть архитектуры с переменной длиной, к примеру, в f32a есть по 5, 1, ил 4 байта. К недостаткам первой можно отнести низкую плотность кода, но при этом такие инструкции легко декодировать, ведь заранее известно, через сколько байт закончится инструкция. К недостаткам второй относится более сложное декодирование (необходим механизм, определяющий длину инструкции), однако это окупается высокой плотностью кода (простые операции занимают меньше места в памяти)

Плотность кода:
Нужно выполнить набор команд. Высокая плотность кода будет означать, что программы будут использовать меньшее количество памяти для выполнения определенного функционала, чем программы с более низкой плотностью кода. Грубо говоря, плотность показывает, насколько эффективно используются n ячеек памяти для решения поставленной задачи.

Проблемы доступа:
Гонки за владение ресурсами при многопоточной обработке, недоступность для ввода-вывода устройств, ограничения размера памяти, перегрузка шины данных из-за большого числа устройств и тд.
# Как вы можете сократить объём машинного кода? Продемонстрируйте.
Спорный вопрос, по идее возникнуть не должен, так как я уверен, что делал все максимально эффективно, но всякое бывает. На практике, к примеру, повторяющиеся участки кода можно выделить в одну процедуру и вызывать её, это сократит объем кода. Просто, смотрите на куски кода и думаете, как я могу это сделать за меньшее число команд. Как вариант, можно добавить чутка неэффективности в программу для защиты от пу-пу-пууу во время ответа на этот вопрос на сдаче.
# risc-iv Работа со стеком. Выделение памяти, передача данных в/из процедур.
Сбор инфы. Stay tuned.
 




 


