https://github.com/ryukzak/wrench/blob/master/src/Isa/Acc32.hs

Аккумуляторная архитектура, в ней единственное хранилище - это аккумулятор (для краткости далее - акк), в него можно загружать какие-то значения, производить с ним действия (результат также загружается в акк)

Пенской (для краткости далее - заебал) сделал так, что мы работаем только с метками, соответственно если вы хотите, к примеру, к акку прибавить 1, то не можете сделать тупа 
```add    1```
так как интерпретатор подумает, что это ссылка и начнутся аномалии, не совершайте моих ошибок)
Чтобы это сделать нужно завести константу, в которой будет лежать операнд и далее пользоваться ей на здоровье
```
.data
const_1:    .word 0x1

.text
_start:
add    const_1
```

Здесь под все почти надо заводить переменные (содержимое метки), чтобы сохранять промежуточные результаты действий, поэтому так часто используются обращения к памяти 

Pc - это счетчик команд, nextPc переходит к следующей инструкции (для вас это новая строка программы)

ISA (в некоторых примерах использования приведены только вырезки программы, фантазируйте, что в акке что-то лежит, там где идет взаимодействие с его содержимым)

# load_imm
Реализация:
```
LoadImm a -> setAcc a >> nextPc
```
Пояснение:
Загружает в акк метку (метка = адрес)

Пример использования:
```
load_imm     ya_krasiviy
```
Что произошло после выполнения:

![image](https://github.com/user-attachments/assets/2bdb7ef6-2eea-48f4-9927-5b876c11b378)

В акк загрузился адрес ссылки ya_krasiviy, то есть 8 в десятичной, скрин взят из dump в отчете wrench 

# load_addr
Реализация:
```
LoadAddr a -> do
value <- getWord $ fromEnum a
setAcc value
nextPc
```
Пояснение:
``` getWord $ fromEnum a ``` это получение слова, на которое указывает метка, оно потом загружается в акк

Пример использования:
```
.data
input_addr:     .word 0x80

.text
_start:
     load_addr    input_addr
```
Что произошло после выполнения:
В акк попало значение 0x80 в шестнадцатиричной

# load_rel
Реализация:
```
LoadRel a -> getWord (pc + fromEnum a) >>= setAcc >> nextPc
```
Пояснение:
Как по мне не раскрыт потенциал этого гавна в реализации Пенского, ибо нельзя вручную устанавливать значение pc, но это есть получение значение со смещением, если будет чет спрашивать, просто скажите, что адресация со смещениям нужна для получения элементов в структурах с фиксированным размером элемента, к примеру, итерация по элементам массива, какого-то адекватного примера я, к сожалению, не нашел, опять же из-за реализации


# load_ind
Реализация:
```
LoadInd a -> do
addr <- getWord $ fromEnum a
value <- getWord $ fromEnum addr
setAcc value
nextPc
```
Пояснение:
Имба штука, позволяет получить и загрузить в акк значение, которое лежит по адресу, на который указывает метка

Пример использования:
```
.data
input_addr:     .word 0x80

.text
_start:
     load_ind    input_addr
```
Что произошло после выполнения:
0x80 заведено под ввод данных, допустим по этом адресу записали слово 0xDA, в акк пойдет именно оно

# store_addr
Реализация:
```
StoreAddr a -> getAcc >>= setWord (fromEnum a) >> nextPc
```
Пояснение:
По аналогии с load_addr

Пример использования:
```
store_addr    result
```
Что произошло после выполнения:
Значение из акка записываем в содержимое метки result (содержимое акка не чистится)


# store_rel
Реализация:
```
StoreRel a -> getAcc >>= setWord (fromEnum (pc + fromEnum a)) >> nextPc
```
Пояснение:
По аналогии с store_rel со всеми вытекающими недостатками


# store_ind
Реализация:
```
StoreInd a -> do
addr <- getWord $ fromEnum a
acc <- getAcc
setWord (fromEnum addr) acc
nextPc
```
Пояснение:
По аналогии с load_ind, используется для записи в output_addr, к примеру

Пример использования:
```
.data
output_addr:     .word 0x84

.text
_start:
     store_ind    output_addr
```
Что произошло после выполнения:
Сначала получается адрес, лежащий в метке, то есть 0x84, и потом в него пишется значения акка


# rem
Реализация:
```
Rem a -> withAcc rem a
```
Пояснение:
Рандомно взятая арифметическая операция нахождения остатка от деления, там есть еще xor, всякие сдвиги, mul, sub и т.д, по аналогии

Пример использования:
```
.data
const_10:     .word 10

.text
_start:
     rem      const_10
```
Что произошло после выполнения:
В акке остаток от деления содержимого акка на 10, к примеру, полезно для нахождения последней цифры числа

# jmp
Реализация:
```
Jmp a -> setPc (fromEnum a)
```
Пояснение:
Безусловный переход

Пример использования:
```
jmp    end
```
Что произошло после выполнения:
Переход на метку end


# beqz
Реализация:
```
Beqz a -> condJmp (== 0) a
```
Пояснение:
Переход с условием, если в акке 0, есть еще условия != 0, > 0, < 0, смотреть ISA, внимательно смотреть, как прописывается название команды в секции MnemonicParser

Пример использования:
```
and     const_1
beqz    even_number
```
Что произошло после выполнения:
Получили последний бит числа в акке, если он 0, то число четное, переходим к его обработке


# halt
Реализация:
```
Halt -> modify $ \st -> st{stopped = True}
```
Пояснение:
Говорит машине тих-тих

Пример использования:
```
end:
    halt
```
Что произошло после выполнения:
Машина ушла на покой
