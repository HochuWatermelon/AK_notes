(https://github.com/ryukzak/wrench/blob/master/docs/acc32.md)

Аккумуляторная архитектура, в ней единственное хранилище - это аккумулятор (для краткости далее - акк), в него можно загружать какие-то значения, производить с ними действия (результат также загружается в акк)


Пенской сделал так, что мы работаем только с метками, соответственно если вы хотите, к примеру, к акку прибавить 1, то не можете сделать тупа 
```add    1```
так как интерпретатор подумает, что это ссылка и начнутся аномалии, не совершайте моих ошибок)
Чтобы это сделать нужно завести константу, в которой будет лежать операнд и далее пользоваться ей на здоровье
```
.data
const_1:    .word 0x1

.text
_start:
add    const_1
```

Здесь под все почти надо заводить переменные (метки с содержимым), чтобы сохранять промежуточные результаты действий, поэтому так часто используются обращения к памяти 

Pc - это счетчик команд, переход к следующей строке команды происходит за счёт прибавления к pc длины инструкции в байтах (она может различаться в зависимости от вида инструкции, смотрите в dump отчёта примеры, сколько байтов занимают различные команды). При условных переходах и jmp в pc загружается адрес метки, куда совершается переход.

Комменты оставляем так
``` ; насрал в комменты ```


Описание доступных команд (в некоторых примерах использования приведены только вырезки программы, фантазируйте, что в акке что-то лежит, там где идет взаимодействие с его содержимым)

# ``` load_imm <address> ``` 
Что делает:
```
acc <- <address>
```
Пояснение:
Загружает в акк метку (метка = адрес)

Пример использования:
```
load_imm     ya_krasiviy
```
Что произошло после выполнения:

![image](https://github.com/user-attachments/assets/2bdb7ef6-2eea-48f4-9927-5b876c11b378)

В акк загрузился адрес ссылки ya_krasiviy, то есть 8 в десятичной, скрин взят из dump в отчете wrench 

# ``` load_addr <address> ```
Что делает:
```
acc <- mem[<address>]
```
Пояснение:
``` mem[<address>]``` это получение из памяти слова, на которое указывает метка, оно потом загружается в акк
Позволяет обращаться к глобальным данным, которые находятся по фиксированным адресам (к примеру, порты ввода-вывода). См. объяснение команды load.

Пример использования:
```
.data
input_addr:     .word 0x80

.text
_start:
     load_addr    input_addr
```
Что произошло после выполнения:
В акк попало значение 0x80 в шестнадцатиричной

# ``` load <offset> ``` 
Что делает:
```
acc <- mem[pc + <offset>]
```
Пояснение:
Как по мне, эта команда работает не так, как надо в реализации Пенского. Если вы напишите работающую корректно программу, используя везде, где требуется, команду load_addr, а после замените все load_addr на load, то получите работающую корректно программу.

Сейчас будет теория, зачем нужны эти два вида адресации, в отрыве от реализации Пенского. load_addr работает с абсолютной адресацией, то есть мы делаем обращение к памяти по точному, известному нам адресу. Удобно, когда данные находятся по фиксированным адресам. load работает с относительной адресацией, то есть загружает значение по адресу, относительно текущего счетчика команд. Адресация со смещением нужна для получения элементов в структурах с фиксированным размером элемента, к примеру, итерация по элементам массива. То есть если в счетчик команд поместить адрес первого элемента массива, то чтобы получить второй, нужно сделать pc + 1, третий pc + 2 и тд. При этом нам не нужно знать конткретный адрес каждого элемента, это удобно.

А теперь, что происходит в acc32. На фото ниже представлен dump памяти программы acc32. Если мы сделаем ``` load_addr input_addr ```, то машина загрузит слово, лежащее по адресу 98 (в десятичной), так input_addr указывает на mem[98..101]. Если же сделать ``` load input_addr ```, то произойдет тоже самое. Мое предположение, что pc, который участвует в реализации команды load, всегда равен нулю, и получается что pc + offset, то есть в данном случае 0 + 98, дают 98, что является меткой input_addr. Команада load должна работать от текущего значения счетчика команд, он при переходе к новой строке программы увеличивается на 1, то есть в разных частях программы load одной и той же метки должна давать разный результат, но в этой архитектуре такого не происходит.

![image](https://github.com/user-attachments/assets/58afebb7-3010-46b7-a821-73b8b31cbf5c)

Если будут задавать вопросы, лучше отвечать, исходя из теории, как это должно работать (массивы яркий пример).

# ``` load_ind <address> ``` 
Что делает:
```
acc <- mem[mem[<address>]]
```
Пояснение:
Имба штука, позволяет загрузить в акк значение, которое лежит по адресу, на который указывает метка

Пример использования:
```
.data
input_addr:     .word 0x80

.text
_start:
     load_ind    input_addr
```
Что произошло после выполнения:
0x80 заведено под ввод данных, допустим по этом адресу записали слово 0xDA, в акк пойдет именно оно

# ``` store_addr <address> ``` 
Что делает:
```
mem[<address>] <- acc
```
Пояснение:
По аналогии с load_addr

Пример использования:
```
store_addr    result
```
Что произошло после выполнения:
Значение из акка записываем в содержимое метки result (содержимое акка не чистится)


# ``` store <offset> ``` 
Что делает:
```
mem[pc + <offset>] <- acc
```
Пояснение:
По аналогии с load со всеми вытекающими приколами


# ``` store_ind <address> ``` 
Что делает:
```
mem[mem[<address>]] <- acc
```
Пояснение:
По аналогии с load_ind, используется для записи в output_addr, к примеру

Пример использования:
```
.data
output_addr:     .word 0x84

.text
_start:
     store_ind    output_addr
```
Что произошло после выполнения:
Сначала получается адрес, лежащий в метке, то есть 0x84, и потом в него пишется значение акка

# ``` clv ``` 
Что делает:
Устанавливает в 0 overflow флаг
Пояснение:
Перед выполнением операций, требующих отслеживания переполнения, необходимо чистить этот флаг

# ``` clс ``` 
Что делает:
Устанавливает в 0 carry флаг
Пояснение:
Перед выполнением операций, требующих отслеживания бита переноса, необходимо чистить этот флаг

# ``` bcs <address> ``` 
Что делает:
Переход к метке, если Carry флаг установлен (то есть равен 1)
Пояснение:
Переход с уловием, что флаг установлен. Есть еще команды bcc - branch if carry flag is clear, bvs - branch if overflow flag is set, bvc - branch if overflow flag is clear

# ``` add <address> ``` 
Что делает:
```
acc <- acc + mem[<address>] and set C and V flags.
```
Пояснение:
Сложение содержимого акка с содержимым метки, при этом выставляются флаги переноса и переполнения. Carry flag может быть полезен, если результат сложения превышает допустимый размер операнда. Overflow flag используется, к примеру, для проверки мувов со знаковыми числами.

Пример использования:
```
.data
max_word:     .word 0xFFFFFFFF
const_1:      .word 0x1

.text
_start:
loop:
     clc 
     load     const_1
     add      max_word
     bcs      carry_flag_is_set
     jmp      loop
carry_flag_is_set:
     halt
```
Что произошло после выполнения:
Создали ситуацию, при которой если carry флаг не устанавливается, происходит бесконечный цикл loop, если же carry флаг устанавливается, машина завершает свою работу. В данном примере мы складываем максимально возможное в пределах word (32 бита) число с единицей, в акке окажется значение 0, а carry flag установится в 1, значит бесконечного цикла не возникнет, и машина завершит свою работу. 
Кста, бесконечный цикл в wrench вызывает следующую ошибку в секции testcase_result отчёта:

![image](https://github.com/user-attachments/assets/523a61b0-17c5-4adb-a489-14a8424d3e50)

Есть еще команды ``` sub ``` для вычитания с установкой V флага, ``` mul ``` для умножения с V флагом, ``` div ``` для деления акка на содержимое метки без выставления флагов


# ``` rem <address> ``` 
Что делает:
```
acc <- acc % mem[<address>]
```
Пояснение:
Операция нахождения остатка от деления содержимого акка на содержимое метки (без флагов)

Пример использования:
```
.data
const_10:     .word 10

.text
_start:
     rem      const_10
```
Что произошло после выполнения:
В акке остаток от деления содержимого акка на 10, к примеру, полезно для нахождения последней цифры числа

# ``` jmp <address> ``` 
Что делает:
```
pc <- <address>
```
Пояснение:
Безусловный переход, используется для перемещения между частями программы. Переход происходит по имени метки (не путать с метками в секции data).

Пример использования:
```
jmp    end
```
Что произошло после выполнения:
Переход к исполнению инструкций, расположенных после метки end.


# ``` beqz <address> ``` 
Что делает:
```
if acc == 0 then pc <- <address>
```
Пояснение:
Переход к метке с условием, что в акке лежит 0. Есть еще условия != 0, > 0, < 0. Смотрите их в доке от Пенского.

Пример использования:
```
and     const_1
beqz    even_number
```
Что произошло после выполнения:
Получили последний бит числа в акке, если он 0, то число четное, переходим к его обработке


# ``` halt ``` 

Пояснение:
Говорит машине тих-тих

Пример использования:
```
end:
    halt
```
Что произошло после выполнения:
Машина ушла на покой
