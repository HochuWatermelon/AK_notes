(https://github.com/ryukzak/wrench/blob/master/docs/acc32.md)

Аккумуляторная архитектура, в ней единственное хранилище - это аккумулятор (для краткости далее - акк), в него можно загружать какие-то значения, производить с ними действия (результат также загружается в акк)


Пенской сделал так, что мы работаем только с метками, соответственно если вы хотите, к примеру, к акку прибавить 1, то не можете сделать тупа 
```add    1```
так как интерпретатор подумает, что это ссылка и начнутся аномалии, не совершайте моих ошибок)
Чтобы это сделать нужно завести константу, в которой будет лежать операнд и далее пользоваться ей на здоровье
```
.data
const_1:    .word 0x1

.text
_start:
add    const_1
```

Здесь под все почти надо заводить переменные (метки с содержимым), чтобы сохранять промежуточные результаты действий, поэтому так часто используются обращения к памяти 

Pc - это счетчик команд, переход к следующей строке команды происходит за счёт прибавления к pc длины инструкции в байтах (она может различаться в зависимости от вида инструкции, смотрите в dump отчёта примеры, сколько байтов занимают различные команды). При условных переходах и jmp в pc загружается адрес метки, куда совершается переход.

Комменты оставляем так
``` ; насрал в комменты ```


Описание доступных команд (в некоторых примерах использования приведены только вырезки программы, фантазируйте, что в акке что-то лежит, там где идет взаимодействие с его содержимым)

# ``` load_imm <address> ``` 
Что делает:
```
acc <- <address>
```
Пояснение:
Загружает в акк метку (метка = адрес)

Пример использования:
```
load_imm     ya_krasiviy
```
Что произошло после выполнения:

![image](https://github.com/user-attachments/assets/2bdb7ef6-2eea-48f4-9927-5b876c11b378)

В акк загрузился адрес ссылки ya_krasiviy, то есть 8 в десятичной, скрин взят из dump в отчете wrench 

# ``` load_addr <address> ```
Что делает:
```
acc <- mem[<address>]
```
Пояснение:
``` mem[<address>]``` это получение из памяти слова, на которое указывает метка, оно потом загружается в акк. Является примером команды с абсолютной адресацией. Адрес занимает 32 бита, мы загружаем его напрямую в инструкцию. У этой инструкции 1 byte for opcode, 4 bytes for absolute operand, то есть в сумме 5 байтов. Посмотрим, как в dump выглядит команда ``` load_addr  res ```. Как видно из скринов ниже, res представляет собой адрес 20 (десятичн.) в памяти, этот адрес и встраивается в инструкцию, занимающую с 32 по 36 байты, то есть 5 байтов. Отличия от команды load описаны ниже.

![image](https://github.com/user-attachments/assets/e5a86ce0-118f-45bc-9c47-e7b6899fc423)

![image](https://github.com/user-attachments/assets/2e4152a8-1b90-458e-8185-34a70d3b9220)



Пример использования:
```
.data
input_addr:     .word 0x80

.text
_start:
     load_addr    input_addr
```
Что произошло после выполнения:
В акк попало значение 0x80 в шестнадцатеричной

# ``` load <offset> ``` 
Что делает:
```
acc <- mem[pc + <offset>]
```
Пояснение:
Команда load работает с относительной адресацией. Instruction size: 1 byte for opcode, 2 bytes for relative operand. Команда загружает значение из адреса, полученного смещением относительно текущего счетчика команд (pc). Разберем подробно комнаду ```load   number```. Вот так она выглядит в dump:

![image](https://github.com/user-attachments/assets/9463f2cd-acc5-442b-a9a8-327bbcad720e)

Обратите внимание на адрес начала инструкции, то есть 43, и число в скобках, то есть (-35), что будет являться смещением. Как получилось это число -35, кароч, смотрим адрес number в памяти, это 8. Всмоминаем адрес начала инструкции load, и делаем 43 - 8, получаем 35. Таким образом произошла загрузка значения из ячейки памяти, которое высчитывается относительно адреса текущей исполняемой команды.

![image](https://github.com/user-attachments/assets/ca511396-b536-49a8-951d-3e6129e08ace)

Но у этого способа загрузки есть ограничение, смещение может быть максимум двухбайтовым числом, то есть 65536 в десятичной. Конечно, в нашей архитектуре, память гораздо меньше, но если представить очень большую программу, памятью в 100000, то возникнут ограничения в использовании load и придется воспользоваться load_addr. 

Если вы напишете работающую корректно программу, используя везде, где требуется, команду load_addr, а после замените все load_addr на load, то получите работающую корректно программу, опять же потому, что выделенной памяти не столь много. Поэтому рекомендуется пользовать именно load, чтобы экономить место в памяти.

Также относительная адресация со смещением нужна для получения элементов в структурах с фиксированным размером элемента, к примеру, итерация по элементам массива в цикле. При этом нам не нужно знать конкретный адрес каждого элемента, это удобно. Однако в нашем acc32 это реализовать не получится, чисто теоретический аспект.



# ``` load_ind <address> ``` 
Что делает:
```
acc <- mem[mem[<address>]]
```
Пояснение:
Имба штука, позволяет загрузить в акк значение, которое лежит по адресу, на который указывает метка

Пример использования:
```
.data
input_addr:     .word 0x80

.text
_start:
     load_ind    input_addr
```
Что произошло после выполнения:
0x80 заведено под ввод данных, допустим по этом адресу записали слово 0xDA, в акк пойдет именно оно

# ``` store_addr <address> ``` 
Что делает:
```
mem[<address>] <- acc
```
Пояснение:
По аналогии с load_addr

Пример использования:
```
store_addr    result
```
Что произошло после выполнения:
Значение из акка записываем в содержимое метки result (содержимое акка не чистится)


# ``` store <offset> ``` 
Что делает:
```
mem[pc + <offset>] <- acc
```
Пояснение:
По аналогии с load со всеми вытекающими приколами


# ``` store_ind <address> ``` 
Что делает:
```
mem[mem[<address>]] <- acc
```
Пояснение:
По аналогии с load_ind, используется для записи в output_addr, к примеру

Пример использования:
```
.data
output_addr:     .word 0x84

.text
_start:
     store_ind    output_addr
```
Что произошло после выполнения:
Сначала получается адрес, лежащий в метке, то есть 0x84, и потом в него пишется значение акка

# ``` clv ``` 
Что делает:
Устанавливает в 0 overflow флаг
Пояснение:
Перед выполнением операций, требующих отслеживания переполнения, необходимо чистить этот флаг

# ``` clс ``` 
Что делает:
Устанавливает в 0 carry флаг
Пояснение:
Перед выполнением операций, требующих отслеживания бита переноса, необходимо чистить этот флаг

# ``` bcs <address> ``` 
Что делает:
Переход к метке, если Carry флаг установлен (то есть равен 1)
Пояснение:
Переход с условием, что флаг установлен. Есть еще команды bcc - branch if carry flag is clear, bvs - branch if overflow flag is set, bvc - branch if overflow flag is clear

# ``` add <address> ``` 
Что делает:
```
acc <- acc + mem[<address>] and set C and V flags.
```
Пояснение:
Сложение содержимого акка с содержимым метки, при этом выставляются флаги переноса и переполнения. Carry flag может быть полезен, если результат сложения превышает допустимый размер операнда. Overflow flag используется, к примеру, для проверки мувов со знаковыми числами.

Пример использования:
```
.data
max_word:     .word 0xFFFFFFFF
const_1:      .word 0x1

.text
_start:
loop:
     clc 
     load     const_1
     add      max_word
     bcs      carry_flag_is_set
     jmp      loop
carry_flag_is_set:
     halt
```
Что произошло после выполнения:
Создали ситуацию, при которой если carry флаг не устанавливается, происходит бесконечный цикл loop, если же carry флаг устанавливается, машина завершает свою работу. В данном примере мы складываем максимально возможное в пределах word (32 бита) число с единицей, в акке окажется значение 0, а carry flag установится в 1, значит бесконечного цикла не возникнет, и машина завершит свою работу. 
Кста, бесконечный цикл в wrench вызывает следующую ошибку в секции testcase_result отчёта:

![image](https://github.com/user-attachments/assets/523a61b0-17c5-4adb-a489-14a8424d3e50)

Есть еще команды ``` sub ``` для вычитания с установкой V флага, ``` mul ``` для умножения с V флагом, ``` div ``` для деления акка на содержимое метки без выставления флагов


# ``` rem <address> ``` 
Что делает:
```
acc <- acc % mem[<address>]
```
Пояснение:
Операция нахождения остатка от деления содержимого акка на содержимое метки (без флагов)

Пример использования:
```
.data
const_10:     .word 10

.text
_start:
     rem      const_10
```
Что произошло после выполнения:
В акке остаток от деления содержимого акка на 10, к примеру, полезно для нахождения последней цифры числа

# ``` jmp <address> ``` 
Что делает:
```
pc <- <address>
```
Пояснение:
Безусловный переход, используется для перемещения между частями программы. Переход происходит по имени метки (не путать с метками в секции data).

Пример использования:
```
jmp    end
```
Что произошло после выполнения:
Переход к исполнению инструкций, расположенных после метки end.


# ``` beqz <address> ``` 
Что делает:
```
if acc == 0 then pc <- <address>
```
Пояснение:
Переход к метке с условием, что в акке лежит 0. Есть еще условия != 0, > 0, < 0. Смотрите их в доке от Пенского.

Пример использования:
```
and     const_1
beqz    even_number
```
Что произошло после выполнения:
Получили последний бит числа в акке, если он 0, то число четное, переходим к его обработке


# ``` halt ``` 

Пояснение:
Говорит машине тих-тих

Пример использования:
```
end:
    halt
```
Что произошло после выполнения:
Машина ушла на покой
