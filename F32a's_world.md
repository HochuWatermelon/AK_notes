https://github.com/ryukzak/wrench/blob/master/src/Isa/F32a.hs

Жалко, пить бросил, под соджу из пятеры сладко бы пошло, но как есть работаем

Стековая архитектура, богиня дискотеки, мисс синтаксис года

Здесь есть два стека: стек данных и стек возврата. Первый используется для хранения данных, второй для хранения адреса возврата, используется в немногих случаях, к примеру, для реализации call и next. Можно делать push для загрузки на стек и pop для чтения элемента со стека

Регистров здесь 6, но мы будем говорить о трех, так как явно используются только они
Регистр p (не путать с p = pc то есть счетчиком команд), a и b
Регистр a используется для хранения адресов и данных, регистр b только для хранения адресов, а регистр p позволяет обращаться к памяти и писать в нее без сохранения в регистр (подобнее в описании команд). Логично, что у нас больше регистров для хранения адресов, так как для данных есть целый стек.

Если в регистре хранится адрес, то можно читать данные из него, то есть делать fetch (@), или писать в него, то есть делать store(!)

Всегда нужно понимать, что и в какой последовательности лежит в стеке и как команды изменяют его содержимое

К синтаксису нужно привыкнуть, будьте готовы к тому, что несколько команд находятся в одной строке (это удобно, на самом деле, если воспринимать команды в строке в совокупности). Есть варик посмотреть, как Пенской смешно ахуевает с программы, которая фул написана в одну строчку, но это опасно для вашего хп, выполнять строго под присмотром взрослых!

Часто встречается случай, когда нужно проделать какие-то проверки с верхним элементом стека данных и при этом дальше нужно каким-то образом взаимодействовать с этим значением, поэтому используется команда dup, которая дублирует верхний элемент и все мувы производятся с ним, в конце обычно делается проверка if'ом, который делает pop из стека данных, и в итоге остается лишь сохраненное ранее значение

alligment боже, сколько нервов было потрачена из-за отсутсвия этого дерьма в коде. Кароч это используется только в стековой архитектуре, находится в коде после input_addr и output_addr в секции .data и выглядит как-то так
``` alligment:     .word '＼(≧▽≦)／_＼(≧▽≦)／_＼(≧▽≦)／_＼(≧▽≦)／_' ```
Он состоит из 32 битов, , то есть полное слово (word без переводчика переводил кста), заполнять можно какими угодно символами. Как я понял, в стековой архитектуре Пенской под данные выделил только 0x80 и 0x84, если мы хотим еще что-то хранить в памяти, то нужно отступить место, равное полному word. Если этого не сделать, то данные из секции .text налезут на секцию .data и вы, скорее всего, положите на лопатки сервер wrench. В действиях Пенских есть логика, так как стековая архитектура призвана в этот мир, чтобы было меньше обращений к памяти, соответственно а зачем вам, мои дорогие, что-то в ней хранить

Проверку на окончание цикла for нужно делать в конце итерации. Есть четыре варианта. Первый, завести отдельную переменную под n + 1 и после инкремента счетчика цикла с помощью xor сравнивать его с этой переменной, если результат 0, то счетчик цикла достиг конца и выходим из него. Второй вариант не заводить эту переменную, а просто делать xor с n перед инкрементом счетчика цикла, n мы уже обработали, и это последнее значение, которое надо обработать, поэтому выходим из цикла. Третий вариант загрузить в стек сразу n и уменьшать его каждую итерацию на 1, в конце итерации если стало 0 это число, то выходим. Четвертый вариант для самых сильных, не выходить из цикла, ведь бесконечность не предел!

ISA (разобраны основные команды, там есть еще парочка, по типу сдвигов или умножения и деления, тут оно выполнено максимально недружелюбно, если хотите, гляньте isa по ссылке)
Обязательно смотрите в реализации, на операции push и pop!

# lit
Реализация:
```
Lit l -> do
                dataPush l
                nextP
```

Пояснение:
Пушится в стек данных число напрямую

Пример использования:
```
lit 10
```

Что произошло после выполнения:
На вершине стека 10 в десятичной системе. Может также быть ```lit random_label``` тогда загружается адрес метки на стек, ПАСИБА

# call
Реализация:
```
Call l -> do
                getP >>= returnPush . toEnum
                setP (fromEnum l)
```

Пояснение:
Используется для вызова выполнения удаленной программы, при этом значения счетчика команд пушится в стек возврата, синтаксис просто название метки в строке без всяких других символов

Пример использования:
```
    do_work
    @ - @
    halt
do_work:
    lit 0
    if callback
callback:
    ;
     
```

Что произошло после выполнения:
Мы прыгнули на do_work, при этом в стек возврата записался адрес команды call (не путать со стеком данных)


# return
Реализация:
```
Return -> returnPop >>= setP . fromEnum >> nextP
```

Пояснение:
Используется для возврата к следующей команде после call, синтаксис просто точка с запятой ```;```
Метка callback используется, чтобы выходить по условию, ведь нельзя написать ```if ;``` так как это воспримется интерпретатором как команад jump, поэтому заводит отдельную метку, куда прыгнем по условию и там прожмем return

Пример использования:
```
    do_work
    @ - @
    halt
do_work:
    lit 0
    if callback
callback:
    ;
```

Что произошло после выполнения:
Помним, что в стеке возврата лежал адрес call, return его берет и переходит к следующей после call команде


# jump
Реализация:
```
Jump l -> do
                setP (fromEnum l)
```

Пояснение:
Безусловный переходит, по синтаксису название метки,  пробел, затем точка с запятой

Пример использования:
```
    kiss_my_ass ;
kiss_my_ass:
    \чмок
    halt
```

Что произошло после выполнения:
Сделали переход на метку, там кста вы видите пример коммента после слэша

# next
Реализация:
```
Next l -> do
                r <- returnPop
                if r == 0
                    then nextP
                    else do
                        returnPush (r - 1)
                        setP (fromEnum l)
```

Пояснение:
Призвана в этом мир, чтобы дарить радость, но сделана через жопу. Кароче эта вкусняшка нужна, чтобы не прописывать плодить условия и, к примеру, хранить в стеке возврата количество итераций цикла, будет просходить переход на метку до тех пор, пока счетчик цикла не станет нулем, после этого будет произведен переход к следующей после next комманде. Используется в случае, если нужно совершить столько-то итераций цикла, но при этом нам не требуется обрабатывать значение счетчика цикла, в наших же вариках чаще всего это делать нужно. Если нужно сделать 32 итерации, то в стек возврата нужно записывать число на 1 меньше, то есть 31 в данном случае

Пример использования:
```
    lit 31 r>                      \ push 31 to return stack

step:
    lit 1 +                        \ к верхнему элементу стека данных будет прибавлено 1

    next step
```

Что произошло после выполнения:
32 раза к верхнему элементу стека будет прибавлена единица

# if
Реализация:
```
If l -> do
                w <- dataPop
                if w == 0
                    then setP (fromEnum l)
                    else nextP
```

Пояснение:
Берется верхний элемент стека данных если он 0, то переход на метку (стек стал на 1 элемент меньше)

Пример использования:
```
lit 0
if equals_zero
equals_zero:
       halt
```

Что произошло после выполнения:
Будет совершен переход, так как на вершину стека мы положили 0

# -if
Реализация:
```
MinusIf l -> do
                w <- dataPop
                if w >= 0
                    then setP (fromEnum l)
                    else nextP
```

Пояснение:
Переход, если на вершине стека число большее или равное 0, спасибо папаша оч удобно

Пример использования:
```
lit 1
-if equals_or_greater_zero
equals_or_greater_zero:
       halt
```

Что произошло после выполнения:
Будет произведен переход

# AStore
Реализация:
```
AStore -> dataPop >>= setA >> nextP
```

Пояснение:
Берется значение со стека данных и кладется в регистр a

Пример использования:
```
lit some_label a!
```

Что произошло после выполнения:
Мы загрузили на стек данных адрес метки и потом положили его в регистр а (я говорил про запись в одну строку, это как раз пример почему так удобно писать)

# BStore
Реализация:
```
BStore -> dataPop >>= setB >> nextP
```

Пояснение:
Тоже самое, что и с AStore

Пример использования:
```
lit 10 b!
```

Что произошло после выполнения:
Ну, тут по приколу загрузили число в 10 в регистр b, ну а че, можем себе позволить

# AFetch
Реализация:
```
AFetch -> getA >>= dataPush >> nextP
```

Пояснение:
Здесь начинаются различия с регистром b, ведь у него нет такой команды. Берется значение из а и пушится на стек. Это пример, когда регистр а используется для хранения данных, а не адреса

Пример использования:
```
lit 69 a!
a
```

Что произошло после выполнения:
На верхушку стека запушится 69, которое мы загрузили в регистр a

# Fetch
Реализация:
```
Fetch -> do
                a <- getA
                w <- getWord $ fromEnum a
                dataPush w
                nextP
```

Пояснение:
В регистре а лежит адрес и мы получаем слово, которое находится по этому адресу

Пример использования:
```
.data
input_addr:    0x80

.text
_start:
lit input_addr a!
@
```

Что произошло после выполнения:
На стек запушится 0x80 (само значение адреса, а не ввод), так как это содержимое адреса, которое перед было загружено в регистр a (для получения input будет более эффективный способ с помощью FetchP) 


# FetchPlus
Реализация:
```
FetchPlus -> do
                a <- getA
                w <- getWord $ fromEnum a
                dataPush w
                setA (a + 1)
                nextP

```

Пояснение:
В регистре a лежит указатель, как и в Fetch, после чтения из памяти по этому адресу значение этого указателя увеличивается на 1, полезно при работе со строками, к примеру, когда нужно считать символ и потом перейти к обработке следующего 

Пример использования:
```
.data
input_addr:    .word 0x80
output_addr:   .word 0x84
alligment:	   .word '################################'
hi:            .byte 'hi'


.text
_start:
      @p output_addr b!
      lit hi a!
      @+
      lit 0xFF and
      !b
      @+
      lit 0xFF and
      !b
      halt
```

Что произошло после выполнения:
Это полный код программы для вывода на вывод строки символов 'hi' в виде ascii кодов в 0x84. Чекните FetchP и возвращайтесь сюда. С возвращением! В регистр b было загружено 0x84, а в регистр a загружен указатель на начало строки hi. @+ считывает целое слово вместо байта, поэтому надо делать маску на байт умножением на 0xFF, после этого указатель в a увеличивается на 1 теперь указывает на второй символ. Чекните StoreB и возвращайтесь сюда. С возвращением!! Пиишем в 0x84 полученный символ.

# FetchB
Реализация:
```
FetchB -> do
                b <- getB
                w <- getWord $ fromEnum b
                dataPush w
                nextP
```

Пояснение:
Тоже самое, что и Fetch

Пример использования:
```
.data
input_addr:    0x80

.text
_start:
lit input_addr b!
@
```

Что произошло после выполнения:
Аналогично FetchA. Удобно сочетать, к примеру, в регистре a хранить указатель, куда писать, а в регистре b хранить, откуда читать

# FetchP
Реализация:
```
FetchP l -> getWord (fromEnum l) >>= dataPush >> nextP
```

Пояснение:
Отличается от Fetch и FetchB тем, что не происходит чтения регистра, а напрямую читается содержимое метки и пушится на стек

Пример использования:
```
.data
input_addr:    0x80

.text
_start:
@p input_addr a!
```

Что произошло после выполнения:
Мы прочитали содержимое input_addr и загрузили его в a, то есть в а лежит 0x80. Если далее делать Fetch, то мы как раз получим слово из ввода

# StoreP
Реализация:
```
StoreP l -> dataPop >>= setWord (fromEnum l) >> nextP
```

Пояснение:
Со стека берется элемент и пишется в содержимое метки, также без обращение к регистрам

Пример использования:
```
@p counter
lit 1 +
!p counter
```

Что произошло после выполнения:
Мы сначала получили содержимое counter, потом увеличили его на 1 и после сохранили его в counter. Удобно использовать, когда не нужно долго хранить какой-то адрес, секс на одну ночь кароч

# StorePlus
Реализация:
```
StorePlus -> do
                w <- dataPop
                a <- getA
                setWord (fromEnum a) w
                setA (a + 1)
                nextP
```

Пояснение:
По примеру FetchPlus думаю разберетесь, также со строками, к примеру, чтобы заполнять посимвольно выделенный буфер в памяти 


Пример использования:
```
.data
input_addr:    .word 0x80
output_addr:   .word 0x84
alligment:	   .word '################################'
hi:            .byte '--'


.text
_start:
      @p input_addr b!
      lit hi a!
      @b
      lit 0xFF and
      !+
      @b
      lit 0xFF and
      !+
      halt
```

Что произошло после выполнения:
С 0x80 последовательно считываем символ 'h' и потом 'i', в регистре a лежит указатель на начало hi, который еще пока не заполнен символами, но потом туда будут поочередно писаться символы

# StoreB
Реализация:
```
StoreB -> do
                w <- dataPop
                b <- getB
                setWord (fromEnum b) w
                nextP
```

Пояснение:
Берется элемент с верхушки стека данных и пишется в адрес, который лежит в регистре b


Пример использования:
```
@p output_addr b!
lit 666
!b
```

Что произошло после выполнения:
В 0x84 будет выгружена татушка Моргена

# Store
Реализация:
```
Store -> do
                a <- getA
                w <- dataPop
                setWord (fromEnum a) w
                nextP
```

Пояснение:
По примеру StoreB

Пример использования:
```
@p output_addr a!
lit siski
!
```

Что произошло после выполнения:
siski это метка, помним, что lit label загружает на стек значение ее адреса, в 0x84 это и пойдет

# add
Реализация:
```
Add -> do
                t <- dataPop
                s <- dataPop
                dataPush (s + t)
                nextP
```

Пояснение:
Видим, что на стеке должны быть оба операнда, они снимаются с вершины, складываются и на стек идет только результат (кол-во элеметов стека уменьшилось на 1). Соответственно, если нужно сохранить какой-то операнд делаем dup, потом загружаем сверху второй операнд и в конце либо убираем результат с помощью условия, либо с помощью drop

Пример использования:
```
lit 10
lit 15 +

```

Что произошло после выполнения:
в стеке будет лишь одно значение 25

# drop
Реализация:
```
Drop -> do
                void dataPop
                nextP
```

Пояснение:
Тупа выкидывает вершину стека данных 

Пример использования:
```
lit 10
lit 15
drop
```

Что произошло после выполнения:
На стеке останется лишь 10

# dup(степ ахах простите)
Реализация:
```
Dup -> do
                w <- dataPop
                dataPush w
                dataPush w
                nextP
```

Пояснение:
Дублирует вершину стека

Пример использования:
```
lit 1
dup
```

Что произошло после выполнения:
На стеке теперь две единицы, ну про мотивацию использовать dup вы уже начитались выше

# over
Реализация:
```
Over -> do
                t <- dataPop
                s <- dataPop
                dataPush t
                dataPush s
                nextP
```

Пояснение:
Меняет местами два верхних элемента стека данных 

Пример использования:
```
lit 10
lit 15
over
```

Что произошло после выполнения:
Теперь верхушка стека это 10, а после него стоит 15

