https://github.com/ryukzak/wrench/blob/master/src/Isa/F32a.hs

Жалко, пить бросил, под соджу из пятеры сладко бы пошло, но как есть работаем

Стековая архитектура, богиня дискотеки, мисс синтаксис года

Здесь есть два стека: стек данных и стек возврата. Первый используется для хранения данных, второй для хранения адреса возврата, используется в немногих случаях, к примеру, для реализации call и next. Можно делать push для загрузки на стек и pop для чтения элемента со стека

Регистров здесь 6, но мы будем говорить о трех, так как явно используются только они
Регистр p (не путать с p = pc то есть счетчиком команд), a и b
Регистр a используется для хранения адресов и данных, регистр b только для хранения адресов, а регистр p позволяет обращаться к памяти и писать в нее без сохранения в регистр (подобнее в описании команд)

Если в регистре хранится адрес, то можно читать данные из него, то есть делать fetch (@), или писать в него, то есть делать store(!)

Всегда нужно понимать, что и в какой последовательности лежит в стеке и как команды изменяют его содержимое

К синтаксису нужно привыкнуть, будьте готовы к тому, что несколько команд находятся в одной строке (это удобно, на самом деле, если воспринимать команды в строке в совокупности). Есть варик посмотреть, как Пенской смешно ахуевает с программы, которая фул написана в одну строчку, но это опасно для вашего хп, выполнять строго под присмотром взрослых!

Часто встречается случай, когда нужно проделать какие-то проверки с верхним элементом стека данных и при этом дальше нужно каким-то образом взаимодействовать с этим значением, поэтому используется команда dup, которая дублирует верхний элемент и все мувы производятся с ним, в конце обычно делается проверка if'ом, который делает pop из стека данных, и в итоге остается лишь сохраненное ранее значение

alligment боже, сколько нервов было потрачена из-за отсутсвия этого дерьма в коде. Кароч это используется только в стековой архитектуре, находится в коде после input_addr и output_addr в секции .data и выглядит как-то так
``` alligment:     .word '＼(≧▽≦)／_＼(≧▽≦)／_＼(≧▽≦)／_＼(≧▽≦)／_' ```
Он состоит из 32 битов, , то есть полное слово (word без переводчика переводил кста), заполнять можно какими угодно символами. Как я понял, в стековой архитектуре Пенской под данные выделил только 0x80 и 0x84, если мы хотим еще что-то хранить в памяти, то нужно отступить место, равное полному word. Если этого не сделать, то данные из секции .text налезут на секцию .data и вы, скорее всего, положите на лопатки сервер wrench. В действиях Пенских есть логика, так как стековая архитектура призвана в этот мир, чтобы было меньше обращений к памяти, соответственно а зачем вам, мои дорогие, что-то в ней хранить

Проверку на окончание цикла for нужно делать в конце итерации. Есть четыре варианта. Первый, завести отдельную переменную под n + 1 и после инкремента счетчика цикла с помощью xor сравнивать его с этой переменной, если результат 0, то счетчик цикла достиг конца и выходим из него. Второй вариант не заводить эту переменную, а просто делать xor с n перед инкрементом счетчика цикла, n мы уже обработали, и это последнее значение, которое надо обработать, поэтому выходим из цикла. Третий вариант загрузить в стек сразу n и уменьшать его каждую итерацию на 1, в конце итерации если стало 0 это число, то выходим. Четвертый вариант для самых сильных, не выходить из цикла, ведь бесконечность не предел!

ISA (разобраны основные команды, там есть еще парочка, по типу сдвигов или умножения и деления, тут оно выполнено максимально недружелюбно, если хотите, гляньте isa по ссылке)
Обязательно смотрите в реализации, на операции push и pop!

# lit
Реализация:
```
Lit l -> do
                dataPush l
                nextP
```

Пояснение:
Пушится в стек данных число напрямую

Пример использования:
```
lit 10
```

Что произошло после выполнения:
На вершине стека 10 в десятичной системе. Может также быть ```lit random_label``` тогда загружается адрес метки на стек, ПАСИБА

# call
Реализация:
```
Call l -> do
                getP >>= returnPush . toEnum
                setP (fromEnum l)
```

Пояснение:
Используется для вызова выполнения удаленной программы, при этом значения счетчика команд пушится в стек возврата, синтаксис просто название метки в строке без всяких других символов

Пример использования:
```
    do_work
    @ - @
    halt
do_work:
    lit 0
    if callback
callback:
    ;
     
```

Что произошло после выполнения:
Мы прыгнули на do_work, при этом в стек возврата записался адрес команды call (не путать со стеком данных)


# return
Реализация:
```
Return -> returnPop >>= setP . fromEnum >> nextP
```

Пояснение:
Используется для возврата к следующей команде после call, синтаксис просто точка с запятой ```;```
Метка callback используется, чтобы выходить по условию, ведь нельзя написать ```if ;``` так как это воспримется интерпретатором как команад jump, поэтому заводит отдельную метку, куда прыгнем по условию и там прожмем return

Пример использования:
```
    do_work
    @ - @
    halt
do_work:
    lit 0
    if callback
callback:
    ;
```

Что произошло после выполнения:
Помним, что в стеке возврата лежал адрес call, return его берет и переходит к следующей после call команде


# jump
Реализация:
```
Jump l -> do
                setP (fromEnum l)
```

Пояснение:
Безусловный переходит, по синтаксису название метки,  пробел, затем точка с запятой

Пример использования:
```
    kiss_my_ass ;
kiss_my_ass:
    \чмок
    halt
```

Что произошло после выполнения:
Сделали переход на метку, там кста вы видите пример коммента после слэша

# next
Реализация:
```
Next l -> do
                r <- returnPop
                if r == 0
                    then nextP
                    else do
                        returnPush (r - 1)
                        setP (fromEnum l)
```

Пояснение:
Призвана в этом мир, чтобы дарить радость, но сделана через жопу. Кароче эта вкусняшка нужна, чтобы не прописывать плодить условия и, к примеру, хранить в стеке возврата количество итераций цикла, будет просходить переход на метку до тех пор, пока счетчик цикла не станет нулем, после этого будет произведен переход к следующей после next комманде. Используется в случае, если нужно совершить столько-то итераций цикла, но при этом нам не требуется обрабатывать значение счетчика цикла, в наших же вариках чаще всего это делать нужно. Если нужно сделать 32 итерации, то в стек возврата нужно записывать число на 1 меньше, то есть 31 в данном случае

Пример использования:
```
    lit 31 r>                      \ push 31 to return stack

step:
    lit 1 +                        \ к верхнему элементу стека данных будет прибавлено 1

    next step
```

Что произошло после выполнения:
32 раза к верхнему элементу стека будет прибавлена единица

# if
Реализация:
```
If l -> do
                w <- dataPop
                if w == 0
                    then setP (fromEnum l)
                    else nextP
```

Пояснение:
Берется верхний элемент стека данных если он 0, то переход на метку (стек стал на 1 элемент меньше)

Пример использования:
```
lit 0
if equals_zero
equals_zero:
       halt
```

Что произошло после выполнения:
Будет совершен переход, так как на вершину стека мы положили 0

# -if
Реализация:
```
MinusIf l -> do
                w <- dataPop
                if w >= 0
                    then setP (fromEnum l)
                    else nextP
```

Пояснение:
Переход, если на вершине стека число большее или равное 0, спасибо папаша оч удобно

Пример использования:
```
lit 1
-if equals_or_greater_zero
equals_or_greater_zero:
       halt
```

Что произошло после выполнения:
Будет произведен переход

# AStore
Реализация:
```
AStore -> dataPop >>= setA >> nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# BStore
Реализация:
```
BStore -> dataPop >>= setB >> nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# AFetch
Реализация:
```
AFetch -> getA >>= dataPush >> nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# FetchPlus
Реализация:
```
FetchPlus -> do
                a <- getA
                w <- getWord $ fromEnum a
                dataPush w
                setA (a + 1)
                nextP

```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# FetchB
Реализация:
```
FetchB -> do
                b <- getB
                w <- getWord $ fromEnum b
                dataPush w
                nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# FetchP
Реализация:
```
FetchP l -> getWord (fromEnum l) >>= dataPush >> nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# Fetch
Реализация:
```
Fetch -> do
                a <- getA
                w <- getWord $ fromEnum a
                dataPush w
                nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# StoreP
Реализация:
```
StoreP l -> dataPop >>= setWord (fromEnum l) >> nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# StorePlus
Реализация:
```
StorePlus -> do
                w <- dataPop
                a <- getA
                setWord (fromEnum a) w
                setA (a + 1)
                nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# StoreB
Реализация:
```
StoreB -> do
                w <- dataPop
                b <- getB
                setWord (fromEnum b) w
                nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# Store
Реализация:
```
Store -> do
                a <- getA
                w <- dataPop
                setWord (fromEnum a) w
                nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# add
Реализация:
```
Add -> do
                t <- dataPop
                s <- dataPop
                dataPush (s + t)
                nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# drop
Реализация:
```
Drop -> do
                void dataPop
                nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# dup
Реализация:
```
Dup -> do
                w <- dataPop
                dataPush w
                dataPush w
                nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


# over
Реализация:
```
Over -> do
                t <- dataPop
                s <- dataPop
                dataPush t
                dataPush s
                nextP
```

Пояснение:


Пример использования:
```

```

Что произошло после выполнения:


