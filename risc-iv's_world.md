https://github.com/ryukzak/wrench/blob/master/src/Isa/RiscIv.hs

Жирков вайбы, у кого были япы уже, в принципе, шарит за эту архитектуру

Итак, у нас есть 7 регистров для хранения данных t0-t6, в них можем загружать данные, адреса,  кароче все кроме своих нюдсов(
Это делает архитектуру очень удобной для работы.


ISA(нет блин ISU)

# addi
Реализация:
```
Addi{rd, rs1, k} -> do
                rs1' <- getReg rs1
                setReg rd (rs1' + k)
                nextPc
```

Пояснение:
К содержимому регистра rs1 добавляется непосредственное значение записанное числом k и записывается результат в rd. Если вы повторно используете addi для записи в тот же регистр rd, перед этим очистите его, чтобы не накладывалось на предыдущий результат (если он вам не нужен, конечно)

Пример использования:
```
.data
input_addr: .word 0x80

.text
_start:
addi t0, t0, input_addr
```

Что произошло после выполнения:
t0 в начале программы 0, поэтому очищать не надо и мы сразу загружаем адрес input_addr (не путать с содержимым input_addr, то есть в t0 не будет лежать 0x80 после выполнения команды)

# li
Реализация:
```
Li{rd, k} -> do
                setReg rd k
                nextPc
```

Пояснение:
Используется для записи непосредственного значения в регистр

Пример использования:
```
li t0, 0
```

Что произошло после выполнения:
Обнулили t0, внеся туда нолик


# add
Реализация:
```
 Add{rd, rs1, rs2} -> rOperation rs1 rs2 rd id id (+)
```

Пояснение:
Содержимое регистра rs1 складывается с rs2 и результат пишется в rd (похожий принцип и у других арифметических и логических операций, смотрите ISA)

Пример использования:
```
li t0, 1
li t1, 2
add t3, t0, t1
```

Что произошло после выполнения:
в t3 будет записана 3, так как 1 + 2 = 3, ладно.

# mv
Реализация:
```
Mv{rd, rs} -> do
                rs' <- getReg rs
                setReg rd rs'
                nextPc
```

Пояснение:
В регистр rd помещается значения регистра rs, при этом содержимое rs остается неизменным

Пример использования:
```
li t1, 6
li t2, 100
mv t1, t2
```

Что произошло после выполнения:
в t1 окажется 100 баллов на Rotten Tomatoes

# sw
Реализация:
```
Sw{rs2, offsetRs1 = MemRef{mrOffset, mrReg}} -> do
                rs2' <- getReg rs2
                mrReg' <- getReg mrReg
                setWord (fromEnum (mrReg' + mrOffset)) rs2'
                nextPc
```

Пояснение:
Хоть и указано смещение, но оно в программе всегда 0 - число перед скобками, то есть мы понимаем, что сохранение слова целиком идет напрямую в адрес, лежащий в регистре, который указывается в скобках

Пример использования:
```
    li      t2, 5555
write_output:
    li      t0, 0
	  addi	  t0, t0, result
	  sw		  t2, 0(t0)
    halt
```

Что произошло после выполнения:
В t0 был загружен адрес метки result, в ее содержимое запишется значение регистра t2, в который мы положили число 5555. Также показан пример обнуления t0 перед операцией addi, выше я объяснял когда это нужно делать

# sb
Реализация:
```
Sb{rs2, offsetRs1 = MemRef{mrOffset, mrReg}} -> do
                rs2' <- getReg rs2
                mrReg' <- getReg mrReg
                setWord (fromEnum (mrReg' + mrOffset)) (0xFF .&. rs2')
                nextPc
```

Пояснение:
Логика такая же, как и с sw, только в данном случае сохраняется не слово, а лишь его младшие 8 бит, используется, к примеру, в строках, когда нам надо выводить символ (8 бит) один за другим.


# lw
Реализация:
```
Lw{rd, offsetRs1 = MemRef{mrOffset, mrReg}} -> do
                rs1' <- getReg mrReg
                w <- getWord $ fromEnum (mrOffset + rs1')
                setReg rd w
                nextPc
```

Пояснение:
Загрузка слова целиком из адреса, лежащего в регистре, который указывается в скобках. Смещение также 0, как и в sw

Пример использования:
```
    li t2, 123
write_output:
    li      t0, 0
	  addi	  t0, t0, out_addr
	  lw		  t0, 0(t0)		; t0 = 0x84
	  sw		  t2, 0(t0)
    halt
```

Что произошло после выполнения:
Содержимое оut_adddr это адрес 0x84, соответственно нам сначала нужно его считать. Для этого мы в t0 загружаем адрес метки out_addr и далее обращаемся в команде lw по этому адресу, загружая в t0 значение 0x84. После происходит сохранение в адрес 0x84 значение регистра t2, то есть 123

# j
Реализация:
```
J{k} -> do
                State{pc} <- get
                setPc (pc + fromEnum k)
```

Пояснение:
Безусловный переход

Пример использования:
```
    j     end
end:
    halt
```

Что произошло после выполнения:
Был совершен переход к метке end

# beqz
Реализация:
```
Beqz{rs1, k} -> do
                State{pc} <- get
                rs1' <- getReg rs1
                if rs1' == 0
                    then setPc (pc + fromEnum k)
                    else nextPc
```

Пояснение:
Условный переход, если содержимое rs1 это ноль.

Пример использования:
```
    li t1, 0
    beqz t1, it_is_zero
it_is_zero:
    halt
```

Что произошло после выполнения:
Будет совершен переход к метке, так как в t1 лежит 0


# bgt
Реализация:
```
Bgt{rs1, rs2, k} -> do
                State{pc} <- get
                rs1' <- getReg rs1
                rs2' <- getReg rs2
                if rs1' > rs2'
                    then setPc (pc + fromEnum k)
                    else nextPc
```

Пояснение:
Условный переход, если содержимое rs1 больше, чем rs2. Отличается от предыдущей команды кол-вом аргументов

Пример использования:
```
    li    t1, 999
    li    t2, 52
    bgt   t1, t2, t1_gt_t2
t1_gt_t2:
    halt
```

Что произошло после выполнения:
Будет совершен переход к метке, так как в t1 лежит число большее, чем в t2. Остальные условия смотреть в ISA. 
