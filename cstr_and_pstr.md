Здесь изложены основные идеи работы со строками. Они будут справедливы для всех архетиктур.

# cstr
Си-строки, в конце строки находится нуль-терминатор, то есть символ \0, его код в таблице это 0, соответственно при выводе строки мы считываем очередной символ и смотрим, если считали 0, то этот символ уже не выводим и выходим из цикла вывода. Чтобы вывести строку загружаем указатель на начало строки и в конце каждой итерации увеличиваем его на 1, чтобы перейти к следующему символу. В конце чтения ввода мы после последнего символа в буфер помещаем символ \0, после передаем указатель на начало буфера и он будет выводится тем же циклом, что и другие строки. 


# pstr
Паскальные строки, перед всеми символами строки находится байт с количеством символов в строке. При выводе строки загружаем указатель на начало строки, помним, что первый байт это длина строки, поэтому берем его за количество итераций (loop_counter который будет либо в переменной и уменьшаться с выводом каждой буквы, либо сохраняться на вершине стека). Байт следующий за первым уже пойдет в вывод. Должен вестись подсчет, сколько символов было введено, по окончании ввода, это кол-во символов мы пишем перед буфером, для этого заранее заводим buf_size: .byte 0, в который загрузится длина строки. Для вывода имени мы передаем указателю адрес buf_size и обрабатываем также, как и другие строки. buf_size увеличивается на 1 и сохраняется после ввода каждого символа, это можно увидеть в логах.

# Общее для обоих видов строк:
alligment боже, сколько нервов было потрачена из-за отсутсвия этого дерьма в коде. 
``` alligment:     .word '＼(≧▽≦)／_＼(≧▽≦)／_＼(≧▽≦)／_＼(≧▽≦)／_' ```
Пользовательский ввод имени заканчивается, когда на вход приходит символ перехода на новую строку \n, в таблице ASCII его код 10, соответственно, каждый приходящий символ мы сравниваем с 10 с помощью xor и в случае, если совпало переходим к обработке конца ввода, для каждой строки она своя. Помним, про маску 0xFF, она нужна для того, чтобы из считанного слова мы выделяли только 8 бит, ведь 1 символ есть 1 байт. По заданию нужно еще и вывести simulation_log содержимое буфера (в нем еще останется место после ввода пользователем имени, она будет заполнено символами, которые не попадут в вывод), туда выведено вся область в памяти, начиная с вопроса и заканчивая "!\n", соответственно, сюда входит и буфер с именем. В логах можно проследить, как заполнялся буфер.
Для примера, вот так в dump выглядит область, заведенная под все строки:

![image](https://github.com/user-attachments/assets/8ac5ded7-7a51-4c4e-a7e1-4356df375f1a)

И в yaml будет отслеживаться после выполнения каждой команды состояние этой области памяти, 0x88 это 136 в hex, а это начало question, а 0xC6 это 198 в hex, что является последним символом final_part

![image](https://github.com/user-attachments/assets/247eae72-0168-428a-a80d-477d664bdc29)



