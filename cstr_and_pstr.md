Здесь изложены основные идеи работы со строками.


# cstr
Си-строки, в конце строки находится нуль-терминатор, то есть символ \0, его код в таблице это 0, соответственно при выводе строки мы считываем очередной символ и смотрим, если считали 0, то этот символ уже не выводим и выходим из цикла вывода. Чтобы вывести строку загружаем указатель на начало строки и в конце каждой итерации увеличиваем его на 1, чтобы перейти к следующему символу. В конце чтения ввода мы после последнего символа в буфер помещаем символ \0, после передаем указатель на начало буфера и он будет выводится тем же циклом, что и другие строки. 


# pstr
Паскальные строки, в начале строки находится байт с количеством символов в строке. При выводе строки загружаем указатель на начало строки, помним, что первый байт это длина строки, поэтому берем его за количество итераций (loop_counter, который будет либо в переменной и уменьшаться с выводом каждой буквы, либо сохраняться на вершине стека). Байт следующий за первым уже пойдет в вывод. Должен вестись подсчет, сколько символов было введено, по окончании ввода, это кол-во символов мы пишем перед буфером, для этого заранее заводим buf_size: .byte 0, в который загрузится длина строки. Для вывода имени мы передаем указателю адрес buf_size и обрабатываем также, как и другие строки. buf_size увеличивается на 1 и сохраняется после ввода каждого символа (справедливо для acc32, f32a), или, если вели подсчет, то сохраняем разово (risc-iv).

